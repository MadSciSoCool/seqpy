from os import path
import zhinst.utils as zu
import numpy as np

# ----------------------------------------------------------
#
#    helper .seQc file generation
#
# ----------------------------------------------------------


class SeqcFile:
    def __init__(self, filepath="") -> None:
        self.file_string = ""
        self._indentation = False
        self.make_header()
        self._filepath = path.join(filepath, "autogenerated.seqc")

    def make_file(self):
        with open(self._filepath, "w") as f:
            f.write(self.file_string)

    def make_header(self):
        self.comment_line("Auto generated by SeqPy")

    def define_placeholder(self, index, length):
        # declare placeholder
        self._writeline(f"wave w{index}_1 = placeholder({length:d}, true);")
        self._writeline(f"wave w{index}_2 = placeholder({length:d}, true);")
        # assign placeholder
        # self._writeline(f"assignWaveIndex(w{index}_1, w{index}_2, 0);")

    def wait(self, samples):
        self._writeline(f"playZero({int(samples):d});")
        # PlayZero should be better for shorter wait time, otherwise use wait, while wait(1) is actually 3 clock cycles
        # self._writeline(f"wait({int(samples):d});")

    def play_wave(self, index):
        self._writeline(f"playWave(w{index}_1, w{index}_2);")

    def start_main_loop(self, iterations):
        self._writeline(f"repeat({int(iterations):d}){{")
        self._indentation = True

    def end_main_loop(self):
        self._indentation = False
        self._writeline("}")

    def comment_line(self, str):
        self._writeline(f"// {str}")

    def _writeline(self, str):
        if self._indentation:
            self.file_string += f"\t{str}\n"
        else:
            self.file_string += f"{str}\n"


def seqc_generation(sequence, filepath=""):
    # write the .seqC file
    wave_length = sequence.length()
    seqc_file = SeqcFile(filepath)
    seqc_file.define_placeholder(0, wave_length)
    seqc_file.start_main_loop(sequence.repetitions)
    seqc_file.play_wave(0)
    seqc_file.wait(sequence.period - wave_length)  # offset to be confirmed
    seqc_file.end_main_loop()
    return seqc_file

# ----------------------------------------------------------
#
#    zhinst wrapper
#
# ----------------------------------------------------------


def update_zhinst_awg(awg, sequence, path=""):
    waveforms = sequence.waveforms()
    if len(waveforms) == 1:
        w1 = waveforms[0]
        w2 = waveforms[0]
    else:
        w1, w2 = waveforms
    waveform = zu.convert_awg_waveform(w1, w2, sequence.marker_waveform())
    seqc = seqc_generation(sequence, path)
    seqc.make_file()
    awg.set_sequence_params(sequence_type="Custom",
                            path=seqc._filepath)
    awg.reset_queue()
    # cheat the awg module

    class WaveformContainer:
        def __init__(self, data) -> None:
            self.data = data
    if "qcodes" in str(type(awg)):
        awg._awg._waveforms = [WaveformContainer(waveform)]
    else:
        awg._waveforms = [WaveformContainer(waveform)]
    awg.compile_and_upload_waveforms()

# ----------------------------------------------------------
#
#    delay calibration
#
# ----------------------------------------------------------


seq_length = 2400

seqc = f"""
// Trigger delay calibration sequence
wave w0_1 = placeholder({2*seq_length}, true);
wave w0_2 = placeholder({2*seq_length}, true);
repeat(1000){{
	playWave(w0_1, w0_2);
	playZero(120000);
}}
"""


def delay_calibration(awg, qa):
    waveform = np.zeros(2*seq_length)
    waveform[:seq_length] = np.linspace(0, 1, seq_length)
    waveform[seq_length:] = np.linspace(1, 0, seq_length)
    marker = np.ones(2*seq_length)
    waveform = zu.convert_awg_waveform(waveform, waveform, marker)

    # write the sequence file
    with open("calibration.seqc", "w") as f:
        f.write(seqc)

    awg.single(0)
    awg.set_sequence_params(sequence_type="Custom",
                            path="calibration.seqc")
    awg.reset_queue()
    # cheat the awg module

    class WaveformContainer:
        def __init__(self, data) -> None:
            self.data = data
    if "qcodes" in str(type(awg)):
        awg._awg._waveforms = [WaveformContainer(waveform)]
    else:
        awg._waveforms = [WaveformContainer(waveform)]
    awg.compile_and_upload_waveforms()
    awg.run()

    # now capture the trace
    qa.qas[0].monitor.reset(1)
    qa.qas[0].monitor.averages(2048)
    qa.qas[0].monitor.length(4096)
    while True:
        if qa.qas[0].monitor.acquired() == 0:
            result = qa.qas[0].monitor.inputs[0].wave()
            break

    # now processing the data
    occurence = np.argmax(result)
    delay = seq_length/2.4e9 - occurence / 1.8e9

    return delay
