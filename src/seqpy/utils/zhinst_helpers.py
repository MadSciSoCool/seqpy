from zhinst.toolkit import Sequence, Waveforms
import numpy as np
import copy
import time
import warnings

# ----------------------------------------------------------
#
#    helper .seQc file generation
#
# ----------------------------------------------------------


class SeqcFile:
    def __init__(self, n_channels) -> None:
        self.file_string = ""
        self._indentation = False
        self._n_channels = n_channels
        self.make_header()

    def make_header(self):
        self.comment_line("Auto generated by SeqPy")

    def define_placeholder(self, length, i, j, marker=True):
        # declare placeholder
        marker_option = "true" if marker else "false"
        self._writeline(
            f"wave w_{i:d}_{j:d} = placeholder({length:d}, {marker_option});"
        )
        # assign placeholder
        # self._writeline(f"assignWaveIndex(w{index}_1, w{index}_2, 0);")

    def wait(self, samples):
        self._writeline(f"playZero({int(samples):d});")
        # PlayZero should be better for shorter wait time, otherwise use wait, while wait(1) is actually 3 clock cycles
        # self._writeline(f"wait({int(samples/8):d});")

    def wait_trigger(self):
        self._writeline("waitDigTrigger(1, 1);")

    def arm_digitization(self):
        # self._writeline("setTrigger(AWG_INTEGRATION_ARM);")
        pass

    def start_digitization(self, wait=0):
        if wait > 0:
            self._writeline(f"wait({int(wait/8):d});")
        # self._writeline(
        #     "setTrigger(AWG_INTEGRATION_ARM + AWG_INTEGRATION_TRIGGER + AWG_MONITOR_TRIGGER);")
        self._writeline("setTrigger(AWG_MONITOR_TRIGGER);")
        self._writeline("setTrigger(0);")
        # self._writeline("setTrigger(AWG_INTEGRATION_ARM);")

    def play_wave(self, *args):
        arguments = ", ".join([f"{channel+1}, w_{i}_{j}" for (channel, i, j) in args])
        self._writeline(f"playWave({arguments});")

    def start_main_loop(self, iterations):
        if iterations < 0:
            self._writeline(f"while(true){{")
        else:
            self._writeline(f"repeat({int(iterations):d}){{")
        self._indentation = True

    def end_main_loop(self):
        self._indentation = False
        self._writeline("}")

    def comment_line(self, str):
        self._writeline(f"// {str}")

    def _writeline(self, str):
        if self._indentation:
            self.file_string += f"\t{str}\n"
        else:
            self.file_string += f"{str}\n"


def seqc_generation(active_times, n_channels, total_length, repetitions, period):
    # write the .seqC file
    n_waveforms = len(active_times)
    seqc_file = SeqcFile(n_channels)
    # define all placeholders
    for j, (start, end) in enumerate(active_times):
        for i in range(n_channels):
            seqc_file.define_placeholder(end - start, i, j)
    seqc_file.start_main_loop(repetitions)
    for i in range(len(active_times)):
        args = [(j, j, i) for j in range(n_channels)]
        seqc_file.play_wave(*args)
        if i < n_waveforms - 1:
            seqc_file.wait(active_times[i + 1][0] - active_times[i][1])
    # offset to be confirmed
    if period > total_length:
        seqc_file.wait(period - total_length)
    else:
        warnings.warn(
            "given period is shorter than pulse length, ignore period instead."
        )
    seqc_file.end_main_loop()
    return seqc_file


def readout_seqc_generation(total_length, digitization_start):
    seqc_file = SeqcFile(2)
    for i in range(2):
        seqc_file.define_placeholder(total_length, i, 0, marker=False)
    seqc_file.start_main_loop(-1)
    seqc_file.wait_trigger()
    seqc_file.arm_digitization()
    seqc_file.play_wave((0, 0, 0), (1, 1, 0))
    seqc_file.start_digitization(wait=digitization_start)
    seqc_file.end_main_loop()
    return seqc_file


def readout_freerun_seqc_generation(total_length):
    seqc_file = SeqcFile(2)
    for i in range(2):
        seqc_file.define_placeholder(total_length, i, 0, marker=False)
    seqc_file.start_main_loop(-1)
    seqc_file.play_wave((0, 0, 0), (1, 1, 0))
    seqc_file.end_main_loop()
    return seqc_file


# ----------------------------------------------------------
#
#    zhinst wrapper
#
# ----------------------------------------------------------
def find_active_time(waveforms, threshold=5000):
    # find the period where at least one channel is not zero
    nonzero = np.any(np.array(waveforms), axis=0)
    nonzero_16 = np.any(nonzero.reshape(-1, 16), axis=1)
    length_16 = len(nonzero_16)
    active_times = list()
    active_flag = False
    p = 0  # current pointer position
    ps = 0  # starting position of this active period
    dead_l = 0  # length of the
    while p < length_16:
        if nonzero_16[p]:  # if current pointer is not zero
            dead_l = 0
            if not active_flag:
                active_flag = (
                    True  # if previously not a active period, now entering one
                )
                ps = p  # register the starting point
        else:  # if current pointer is zero
            if active_flag:
                dead_l = dead_l + 1
                if dead_l * 16 > threshold:
                    active_flag = False  # if previously a zero period, now exiting
                    # add this period if its length beyond the threshold
                    active_times.append((ps * 16, (p + 1 - dead_l) * 16))
                    dead_l = 0
        p = p + 1
    # handle last active period
    if active_flag:
        active_times.append((ps * 16, p * 16))
    return active_times


def update_zhinst_uhfqa(uhfqa, sequence, samp_freq=None, freerun=False):
    if not samp_freq:
        samp_freq = 1.8e9
    waveforms = copy.deepcopy(sequence.waveforms(samp_freq=samp_freq))
    n_channels = len(waveforms)
    if n_channels > 2:
        raise (
            Exception(
                "the maximum channel number supported for Zurich Instruments UHFQA is 2."
            )
        )
    elif n_channels == 1:
        # padded to 2 channels
        waveforms.append(np.zeros(sequence.length()))
    waveforms = np.array(waveforms)
    digitization_start = sequence.trigger_pos * samp_freq - sequence.left
    if not freerun:
        seqc = readout_seqc_generation(
            total_length=sequence.length(), digitization_start=digitization_start
        )
    else:
        seqc = readout_freerun_seqc_generation(total_length=sequence.length())
    # compile the nominal awg
    # uhfqa.awg.set_sequence_params(sequence_type="Custom", path=seqc._filepath)
    # # upload the waveforms
    # uhfqa.awg.reset_queue()
    # uhfqa.awg.queue_waveform(*waveforms)
    # uhfqa.awg.compile_and_upload_waveforms()
    awg_program = Sequence()
    awg_program.code = seqc.file_string
    uploaded_waveforms = Waveforms()
    uploaded_waveforms[0] = (waveforms[0], waveforms[1])
    with uhfqa.set_transaction():
        uhfqa.awgs[0].load_sequencer_program(awg_program)
        uhfqa.awgs[0].write_to_waveform_memory(uploaded_waveforms)
        uhfqa.awgs[0].enable(True)


# somehow the channel grouping is not working with offline compilation, so switch to awg module for n_channels >= 3


def compile_seqc(session, device, seqc):
    awg = session.modules.awg
    awg.device(device.serial)
    awg.index(0)
    awg.sequencertype("auto-detect")
    awg.execute()
    awg.compiler.sourcestring(seqc)

    # The following lines are not mandatory but only to ensure that everything was compiled and uploaded correctly.
    timeout = 100.0  # seconds
    compiler_status = awg.compiler.status()
    start = time.time()
    while compiler_status == -1:
        if time.time() - start >= timeout:
            raise TimeoutError("Program compilation timed out")
        time.sleep(0.1)
        compiler_status = awg.compiler.status()
    if compiler_status == 1:
        raise RuntimeError(
            "Error during sequencer compilation. Check the log for detailed information"
        )
    if compiler_status == 2:
        print(f"Warning during sequencer compilation {awg.compiler.statusstring()}")
    # Check and wait until the elf upload to the device was successful
    progress = awg.progress()
    while progress < 1.0 or awg.elf.status() == 2 or device.awgs[0].ready() == 0:
        if time.time() - start >= timeout:
            raise TimeoutError(f"Program upload timed out")
        time.sleep(0.1)
        progress = awg.progress()
    if awg.elf.status() or not device.awgs[0].ready():
        raise RuntimeError(
            "Error during upload of ELF file. Check the log for detailed information"
        )


padding = [2, 1, 0, 1, 0, 3, 2, 1, 0]


def update_zhinst_hdawg(
    hdawg, session, sequence, period, repetitions=-1, samp_freq=None
):
    if not samp_freq:
        samp_freq = 2.4e9
    waveforms = copy.deepcopy(sequence.waveforms(samp_freq=samp_freq))
    # pad one channel if odd
    n_channels = len(waveforms)
    if n_channels > 8:
        raise (
            Exception(
                "the maximum channel number supported for Zurich Instruments HDAWG is 8."
            )
        )
    for i in range(padding[n_channels]):
        waveforms.append(np.zeros(sequence.length()))
        n_channels += 1
    hdawg.awgs[0].enable(False)  # need to stop before change channel grouping
    hdawg.system.awg.channelgrouping(
        np.log2(n_channels - 1)
    )  # update channel group in zhinst-toolkit 0->2*4, 1->4*2, 2->8*1
    # find active time
    active_times = find_active_time(waveforms + [sequence.marker_waveform()])
    # generate and compile the .seqc file
    seqc = seqc_generation(
        active_times=active_times,
        n_channels=n_channels,
        total_length=sequence.length(),
        repetitions=repetitions,
        period=int(period * samp_freq),
    )
    # awg_program = Sequence()
    # awg_program.code = seqc.file_string
    compile_seqc(session, hdawg, seqc.file_string)

    # queue the waveforms, setup everything
    with hdawg.set_transaction():
        for i in range(n_channels // 2):
            uploaded_waveforms = Waveforms()
            ind = 0
            for start, end in active_times:
                uploaded_waveforms.assign_waveform(
                    ind,
                    waveforms[2 * i][start:end],
                    waveforms[2 * i + 1][start:end],
                    sequence.marker_waveform()[start:end],
                )
                ind += 1
            hdawg.awgs[i].write_to_waveform_memory(uploaded_waveforms)
        # hdawg.awgs[0].enable(True)
