from os import path
import seqpy
import zhinst.utils as zu
import numpy as np
import copy

# ----------------------------------------------------------
#
#    helper .seQc file generation
#
# ----------------------------------------------------------


class SeqcFile:
    def __init__(self, n_channels, filepath="") -> None:
        self.file_string = ""
        self._indentation = False
        self._n_channels = n_channels
        self.make_header()
        self._filepath = path.join(filepath, "autogenerated.seqc")

    def make_file(self):
        with open(self._filepath, "w") as f:
            f.write(self.file_string)

    def make_header(self):
        self.comment_line("Auto generated by SeqPy")

    def define_placeholder(self, length, i, j, marker=True):
        # declare placeholder
        marker_option = "true" if marker else "false"
        self._writeline(
            f"wave w_{i:d}_{j:d} = placeholder({length:d}, {marker_option});")
        # assign placeholder
        # self._writeline(f"assignWaveIndex(w{index}_1, w{index}_2, 0);")

    def wait(self, samples):
        self._writeline(f"playZero({int(samples):d});")
        # PlayZero should be better for shorter wait time, otherwise use wait, while wait(1) is actually 3 clock cycles
        # self._writeline(f"wait({int(samples):d});")

    def awg_monitor_trig(self):
        self._writeline("waitDigTrigger(1, 1);")
        self._writeline("setTrigger(AWG_MONITOR_TRIGGER);")
        self._writeline("setTrigger(0);")

    def play_wave(self, *args):
        arguments = ", ".join(
            [f"{channel+1}, w_{i}_{j}" for (channel, i, j) in args])
        self._writeline(f"playWave({arguments});")

    def start_main_loop(self, iterations):
        if iterations < 0:
            self._writeline(f"repeat(true){{")
        else:
            self._writeline(f"repeat({int(iterations):d}){{")
        self._indentation = True

    def end_main_loop(self):
        self._indentation = False
        self._writeline("}")

    def comment_line(self, str):
        self._writeline(f"// {str}")

    def _writeline(self, str):
        if self._indentation:
            self.file_string += f"\t{str}\n"
        else:
            self.file_string += f"{str}\n"


def seqc_generation(alivetimes, deadtimes, n_channels, total_length, repetitions, period, file_path=""):
    # write the .seqC file
    n_waveforms = len(alivetimes)
    seqc_file = SeqcFile(n_channels, file_path)

    # define all placeholders
    for i in range(n_channels):
        for j, (start, end) in enumerate(alivetimes):
            seqc_file.define_placeholder(end-start, i, j)
    seqc_file.start_main_loop(repetitions)
    for i in range(len(alivetimes)):
        args = [(j, j, i) for j in range(n_channels)]
        seqc_file.play_wave(*args)
        if i < n_waveforms - 1:
            seqc_file.wait(deadtimes[i][1] - deadtimes[i][0])
    # offset to be confirmed
    seqc_file.wait(max(period - total_length, 1))
    seqc_file.end_main_loop()
    return seqc_file


def readout_seqc_generation(total_length, file_path):
    seqc_file = SeqcFile(2, file_path)
    for i in range(2):
        seqc_file.define_placeholder(total_length, i, 0, marker=False)
    seqc_file.start_main_loop(-1)
    seqc_file.awg_monitor_trig()
    seqc_file.play_wave((0, 0, 0), (1, 1, 0))
    seqc_file.end_main_loop()
    return seqc_file


# ----------------------------------------------------------
#
#    zhinst wrapper
#
# ----------------------------------------------------------

# cheat the awg module


def find_deadtime(waveforms, threshold=5000):
    is_zero = np.all(np.array(waveforms) == 0, axis=0)
    deadtimes = list()
    current_length = 0
    current_start = 0
    zero_flag = False
    for i in range(len(is_zero)):
        if is_zero[i]:
            if not zero_flag:
                zero_flag = True  # if previously not a zero period, now entering one
                current_start = i  # register the starting point
            else:
                current_length += 1  # if already in zero period, add length by one
        else:
            if zero_flag:
                zero_flag = False  # if previously a zero period, now exiting
                if current_length > threshold:
                    # add this period if its length beyond the threshold
                    deadtimes.append((current_start, i))
                current_length = 0
            else:
                pass
    return deadtimes


class WaveformContainer:
    def __init__(self, data) -> None:
        self.data = data


def update_zhinst_awg(awg, sequence, period, repetitions, path=""):
    waveforms = copy.deepcopy(sequence.waveforms())
    # pad one channel if odd
    n_channels = len(waveforms)
    if n_channels > 8:
        raise(Exception(
            "the maximum channel number supported for Zurich Instruments HDAWG is 8."))
    if n_channels % 2 == 1:
        waveforms.append(np.zeros(sequence.length()))
        n_channels += 1
    # here change the awg grouping
    awg.awgs[0].stop()  # need to stop before change channel grouping
    awg.system.awg.channelgrouping(
        np.log2(n_channels - 1))  # 0->2*4, 1->4*2, 2->8*1
    # find common deadtime
    deadtimes = find_deadtime(waveforms + [sequence.marker_waveform()])
    # conjugate part
    alivetimes = list()
    # the conjugate part for deadtimes
    start = 0
    end = sequence.length()
    for s, e in deadtimes:
        alivetimes.append((start, s + (start - s) % 16))
        start = e
    alivetimes.append((start + (end - start) % 16, end))
    # upload the .seqc file
    seqc = seqc_generation(alivetimes=alivetimes,
                           deadtimes=deadtimes,
                           n_channels=n_channels,
                           total_length=sequence.length(),
                           repetitions=repetitions,
                           period=period,
                           file_path=path)
    seqc.make_file()
    awg.awgs[0].set_sequence_params(sequence_type="Custom",
                                    path=seqc._filepath)
    # queue the waveforms
    for i in range(n_channels//2):
        awg.awgs[i].reset_queue()
    for i in range(n_channels//2):
        for start, end in alivetimes:
            waveform = zu.convert_awg_waveform(
                waveforms[2 * i][start:end],
                waveforms[2 * i + 1][start:end],
                sequence.marker_waveform()[start:end])
            if "qcodes" in str(type(awg)):
                awg.awgs[i]._awg._waveforms.append(WaveformContainer(waveform))
            else:
                awg.awgs[i]._waveforms.append(WaveformContainer(waveform))
    # compile the nominal awg
    awg.awgs[0].compile()
    # upload the waveforms
    for i in range(n_channels//2):
        awg.awgs[i].upload_waveforms()


def update_zhinst_qa(qa, sequence, path=""):
    # remember to change the sampling rate before running this code
    waveforms = copy.deepcopy(sequence.waveforms())
    n_channels = len(waveforms)
    if n_channels > 2:
        raise(Exception(
            "the maximum channel number supported for Zurich Instruments UHFQA is 2."))
    elif n_channels == 1:
        # padded to 2 channels
        waveforms.append(np.zeros(sequence.length()))
    seqc = readout_seqc_generation(
        total_length=sequence.length(), file_path=path)
    seqc.make_file()
    # compile the nominal awg
    qa.awg.set_sequence_params(sequence_type="Custom", path=seqc._filepath)
    # upload the waveforms
    qa.awg.reset_queue()
    qa.awg.queue_waveform(*waveforms)
    qa.awg.compile_and_upload_waveforms()
